---
title: "Scorigami!"
subtitle: "Using Markov Chains to Model Unique NFL Game Scores"
subject: "Stat 322: Finite Markov Chains and Applications"
author: "Austin Redmond"
affiliation: "MacEwan University, Department of Mathematics and Statistics"
email: "redmonda6@mymacewa.ca"
date: "3/12/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, root.dir = "~/GitHub/ScorigamiMC")
```

# Introduction

#### Project Description and Objectives 

  Scorigami is the "art of achieving a final score in an NFL game that has never happened before" (Bois). John Bois, an editor and sportswriter at SB Nation (Colon), invented the term Scorigami in December of 2016. The final score of an NFL game consists of the total points scored by each of the two teams. There are six ways to score points in an NFL game. The two most common ways to score are the 3-point field goal and 7-point touchdown with a successful point-after-attempt. The next three less common ways of scoring are the: 2-point safety; 6-point touchdown with a failed conversion; and the 8-point touchdown with a successful 2-point conversion. The final and nearly impossible way to score is the 1-point safety. The 1-point safety has never occurred in the NFL but it is technically possible as "a team making an extra-point attempt [could] botch the play so badly, they would end up in their own endzone, 98-yards away, and then get tackled in the endzone" (Nogle). The irregular distribution of scoring methods and the relatively smaller sample size from a limited number of exactly 256 regular season and 12 postseason games per year means that many final NFL scores that are possible have never actually happened. The website https://nflscorigami.com/ has a detailed representation of each final score that has and has not occurred. The topic of this project is related to using Markov Chains to project the probability of a unique final NFL score (otherwise known as a Scorigami) happening given parameters related to the the current score and how many quarters are yet to occur in the game. 
  
  For this analysis each score, where one team is defined as the winning team and the other is defined as the losing team, is considered a state in the Markov Chain. The team that is winning may change from quarter-to-quarter. In the data set, it is found that the largest amount of points scored in a single quarter by a team is 31 points. Using this information as a guideline, the upper bound of states will be a final score of 124-124. The score of 124-124 is based off both teams scoring 31 points per quarter for all four quarters. The scenario described is very extreme compared to actual events where: the highest number of points scored in one game by one team is 73 and the highest number of combined points scored by two teams is 105 points (NFL Scorigami). States are recorded at the start of the game (where the score is always equal to 0-0) and at the end of every quarter. Completing a quarter of play will be considered one transition. Meaning each NFL game will have exactly four transitions. Overtime will not be considered. If teams are tied at the end of regulation, then the score will be considered final. It can be assumed that the first, second, third, and fourth quarter have the same or least similar scoring distributions. However, it is clear that overtime, which has a limited number of scoring scenarios, has a scoring distribution that is very different from the other quarters. 
  
#### Literature Review

# Methodology

### My Library

My library consists of functions a quick

```{r My Library, message=FALSE}

library(dplyr, nflscrapR)

multi_scrape_game_ids <- function(seasons, types, weeks = NULL, teams = NULL) {
  library(nflscrapR)
  
  #Schema of the scraped game IDs data frame.
  scrapedGameIDsColNames <- c("type", "game_id", "home_team", "away_team", "week", "season", "state_of_game", "game_url", "home_score", "away_score")
  #Create scraped game IDs data frame with a matching number of columns.
  scrapedGameIDs <- as.data.frame(matrix(,0,length(scrapedGameIDsColNames)))
  #Rename columns of scraped game IDs data frame.
  names(scrapedGameIDs) <- scrapedGameIDsColNames
  
  #Loop for each season and each type of game (which is either preseason, regular season, or postseason).
  for(s in seasons) {
    for(ty in types) {
      #Bind the data scraped so far with the data scraped using the current season, game type, week, and team information.
      scrapedGameIDs <- rbind(scrapedGameIDs, scrape_game_ids(s, ty, weeks = weeks, teams = teams))
    }
  }
  
  #Return the scraped gamed IDs data frame.
  return(scrapedGameIDs)
}

multi_scrape_game_play_by_play <- function(gameIDs) {
  library(nflscrapR)  
  
  #Create an empty list for each game ids' play-by-play data.
  scrapedGamePlayByPlayList = list()
  
  #Loop for each game id.
  for(i in 1:nrow(gameIDs)) {
    #Bind the data scraped so far with the data scraped using the current game id.
    tempScrapedGamePlayByPlay <- scrape_game_play_by_play(gameIDs[i,"game_id"], gameIDs[i,"type"], gameIDs[i,"season"], 0)
    scrapedGamePlayByPlayList[[i]] <- tempScrapedGamePlayByPlay[tempScrapedGamePlayByPlay$quarter_end==1,c("game_id","home_team","away_team","qtr","total_home_score","total_away_score")]
  }
  
  #
  scrapedGamePlayByPlay <- do.call(rbind, scrapedGamePlayByPlayList)
  
  scrapedGamePlayByPlay <- scrapedGamePlayByPlay[complete.cases(scrapedGamePlayByPlay), ]
  
  scrapedGamePlayByPlay <- unique(scrapedGamePlayByPlay)

  return(scrapedGamePlayByPlay)
}

game_data <- function(gameIDs, gamePlayByPlay) {

  n <- length(gameIDs$game_id)
  
  game_id <- gameIDs$game_id
  home_team <- gameIDs$home_team
  away_team <- gameIDs$away_team
  
  qtr1_home_score <- rep(NA, length=n)
  qtr1_away_score <- rep(NA, length=n)
  qtr2_home_score <- rep(NA, length=n)
  qtr2_away_score <- rep(NA, length=n)
  qtr3_home_score <- rep(NA, length=n)
  qtr3_away_score <- rep(NA, length=n)
  qtr4_home_score <- rep(NA, length=n)
  qtr4_away_score <- rep(NA, length=n)
  
  final_home_score <- gameIDs$home_score 
  final_away_score <- gameIDs$away_score
  
  for(i in 1:length(game_id)){
    tryCatch({qtr1_home_score[[i]] <- as.numeric(gamePlayByPlay[gamePlayByPlay$game_id==game_id[i]&gamePlayByPlay$qtr==1,][[1,"total_home_score"]])}, error=function(e){})
    tryCatch({qtr1_away_score[[i]] <- as.numeric(gamePlayByPlay[gamePlayByPlay$game_id==game_id[i]&gamePlayByPlay$qtr==1,][[1,"total_away_score"]])}, error=function(e){})
    tryCatch({qtr2_home_score[[i]] <- as.numeric(gamePlayByPlay[gamePlayByPlay$game_id==game_id[i]&gamePlayByPlay$qtr==2,][[1,"total_home_score"]])}, error=function(e){})
    tryCatch({qtr2_away_score[[i]] <- as.numeric(gamePlayByPlay[gamePlayByPlay$game_id==game_id[i]&gamePlayByPlay$qtr==2,][[1,"total_away_score"]])}, error=function(e){})
    tryCatch({qtr3_home_score[[i]] <- as.numeric(gamePlayByPlay[gamePlayByPlay$game_id==game_id[i]&gamePlayByPlay$qtr==3,][[1,"total_home_score"]])}, error=function(e){})
    tryCatch({qtr3_away_score[[i]] <- as.numeric(gamePlayByPlay[gamePlayByPlay$game_id==game_id[i]&gamePlayByPlay$qtr==3,][[1,"total_away_score"]])}, error=function(e){})
    tryCatch({qtr4_home_score[[i]] <- as.numeric(gamePlayByPlay[gamePlayByPlay$game_id==game_id[i]&gamePlayByPlay$qtr==4,][[1,"total_home_score"]])}, error=function(e){})
    tryCatch({qtr4_away_score[[i]] <- as.numeric(gamePlayByPlay[gamePlayByPlay$game_id==game_id[i]&gamePlayByPlay$qtr==4,][[1,"total_away_score"]])}, error=function(e){})
  }
  
  gameData <- do.call(cbind,list(game_id, home_team, away_team, qtr1_home_score, qtr1_away_score, qtr2_home_score, qtr2_away_score, qtr3_home_score, qtr3_away_score, qtr4_home_score, qtr4_away_score, final_home_score, final_away_score))
  rownames(gameData) <- 1:n
  colnames(gameData) <- c("game_id", "home_team", "away_team", "qtr1_home_score", "qtr1_away_score", "qtr2_home_score", "qtr2_away_score", "qtr3_home_score", "qtr3_away_score", "qtr4_home_score", "qtr4_away_score", "final_home_score", "final_away_score")
  gameData <- as.data.frame(gameData)
  
  return(gameData)
}

points_scored_frequency <- function(gameData){
  
  pointsScoredFrequency <- matrix(rep(0, 32*32), nrow = 32, ncol=32)
  rownames(pointsScoredFrequency) <- 0:31
  colnames(pointsScoredFrequency) <- 0:31
  
  winning_team_scored <- NULL
  losing_team_scored <- NULL
  
  for(i in 1:length(gameData$game_id)){
  
    tryCatch({
      winning_team_scored <- as.character(max(as.numeric(as.character(gameData$qtr1_home_score[i])),as.numeric(as.character(gameData$qtr1_away_score[i]))))
      losing_team_scored <- as.character(min(as.numeric(as.character(gameData$qtr1_home_score[i])),as.numeric(as.character(gameData$qtr1_away_score[i]))))
      pointsScoredFrequency[losing_team_scored,winning_team_scored] <- pointsScoredFrequency[losing_team_scored,winning_team_scored] + 1
    }, error=function(e){})
    
    tryCatch({
      if(as.numeric(as.character(gameData$qtr1_home_score[i]))>as.numeric(as.character(gameData$qtr1_away_score[i]))){
        winning_team_scored <- as.character(as.numeric(as.character(gameData$qtr2_home_score[i])) - as.numeric(as.character(gameData$qtr1_home_score[i])))
        losing_team_scored <- as.character(as.numeric(as.character(gameData$qtr2_away_score[i])) - as.numeric(as.character(gameData$qtr1_away_score[i])))
      } else if(as.numeric(as.character(gameData$qtr1_home_score[i]))<as.numeric(as.character(gameData$qtr1_away_score[i]))) {
        winning_team_scored <- as.character(as.numeric(as.character(gameData$qtr2_away_score[i])) - as.numeric(as.character(gameData$qtr1_away_score[i])))
        losing_team_scored <- as.character(as.numeric(as.character(gameData$qtr2_home_score[i])) - as.numeric(as.character(gameData$qtr1_home_score[i])))
      } else {
        winning_team_scored <- as.character(max(as.numeric(as.character(gameData$qtr2_home_score[i])) - as.numeric(as.character(gameData$qtr1_home_score[i])),
                                                as.numeric(as.character(gameData$qtr2_away_score[i])) - as.numeric(as.character(gameData$qtr1_away_score[i]))))
        losing_team_scored <- as.character(min(as.numeric(as.character(gameData$qtr2_home_score[i])) - as.numeric(as.character(gameData$qtr1_home_score[i])),
                                               as.numeric(as.character(gameData$qtr2_away_score[i])) - as.numeric(as.character(gameData$qtr1_away_score[i]))))
      }
      pointsScoredFrequency[losing_team_scored,winning_team_scored] <- pointsScoredFrequency[losing_team_scored,winning_team_scored] + 1
        
    },error=function(e){})
    
    tryCatch({
      if(as.numeric(as.character(gameData$qtr2_home_score[i]))>as.numeric(as.character(gameData$qtr2_away_score[i]))){
        winning_team_scored <- as.character(as.numeric(as.character(gameData$qtr3_home_score[i])) - as.numeric(as.character(gameData$qtr2_home_score[i])))
        losing_team_scored <- as.character(as.numeric(as.character(gameData$qtr3_away_score[i])) - as.numeric(as.character(gameData$qtr2_away_score[i])))
      } else if(as.numeric(as.character(gameData$qtr2_home_score[i]))<as.numeric(as.character(gameData$qtr2_away_score[i]))) {
        winning_team_scored <- as.character(as.numeric(as.character(gameData$qtr3_away_score[i])) - as.numeric(as.character(gameData$qtr2_away_score[i])))
        losing_team_scored <- as.character(as.numeric(as.character(gameData$qtr3_home_score[i])) - as.numeric(as.character(gameData$qtr2_home_score[i])))
      } else {
        winning_team_scored <- as.character(max(as.numeric(as.character(gameData$qtr3_home_score[i])) - as.numeric(as.character(gameData$qtr2_home_score[i])),
                                                as.numeric(as.character(gameData$qtr3_away_score[i])) - as.numeric(as.character(gameData$qtr2_away_score[i]))))
        losing_team_scored <- as.character(min(as.numeric(as.character(gameData$qtr3_home_score[i])) - as.numeric(as.character(gameData$qtr2_home_score[i])),
                                               as.numeric(as.character(gameData$qtr3_away_score[i])) - as.numeric(as.character(gameData$qtr2_away_score[i]))))
      }
      pointsScoredFrequency[losing_team_scored,winning_team_scored] <- pointsScoredFrequency[losing_team_scored,winning_team_scored] + 1
        
    },error=function(e){})
    
    tryCatch({
      if(as.numeric(as.character(gameData$qtr3_home_score[i]))>as.numeric(as.character(gameData$qtr3_away_score[i]))){
        winning_team_scored <- as.character(as.numeric(as.character(gameData$qtr4_home_score[i])) - as.numeric(as.character(gameData$qtr3_home_score[i])))
        losing_team_scored <- as.character(as.numeric(as.character(gameData$qtr4_away_score[i])) - as.numeric(as.character(gameData$qtr3_away_score[i])))
      } else if(as.numeric(as.character(gameData$qtr3_home_score[i]))<as.numeric(as.character(gameData$qtr3_away_score[i]))) {
        winning_team_scored <- as.character(as.numeric(as.character(gameData$qtr4_away_score[i])) - as.numeric(as.character(gameData$qtr3_away_score[i])))
        losing_team_scored <- as.character(as.numeric(as.character(gameData$qtr4_home_score[i])) - as.numeric(as.character(gameData$qtr3_home_score[i])))
      } else {
        winning_team_scored <- as.character(max(as.numeric(as.character(gameData$qtr4_home_score[i])) - as.numeric(as.character(gameData$qtr3_home_score[i])),
                                                as.numeric(as.character(gameData$qtr4_away_score[i])) - as.numeric(as.character(gameData$qtr3_away_score[i]))))
        losing_team_scored <- as.character(min(as.numeric(as.character(gameData$qtr4_home_score[i])) - as.numeric(as.character(gameData$qtr3_home_score[i])),
                                               as.numeric(as.character(gameData$qtr4_away_score[i])) - as.numeric(as.character(gameData$qtr3_away_score[i]))))
      }
      pointsScoredFrequency[losing_team_scored,winning_team_scored] <- pointsScoredFrequency[losing_team_scored,winning_team_scored] + 1
        
    },error=function(e){})
  }
  
  return(pointsScoredFrequency)
  
}

points_scored_observations <- function(pointsScoredFrequency) {
  
  pointsScoredObservations <- list()

  for(c in as.character(0:31)) {
    for(r in as.character(0:31)) {
      n <- pointsScoredFrequency[r,c]
      temp <- list()
      tryCatch({
        temp <- list()
        for (i in 1:n) {
          temp[[i]] <- c(as.numeric(as.character(r)), as.numeric(as.character(c)))
        }
        pointsScoredObservations <- append(pointsScoredObservations, temp)
      },error=function(e){})
    }
  }
  
  pointsScoredObservations <- do.call(rbind, pointsScoredObservations)
  colnames(pointsScoredObservations) <- c("losing_team_points_scored","winning_team_points_scored")
  
  pointsScoredObservations <- as.data.frame(pointsScoredObservations)
  
  return(pointsScoredObservations)
}

initial_distribution <- function(states, givenState) {
  
  #Create matrix of size 1 column and the same number of rows as the number of states.
  initialDistribution <- matrix(rep(0, length(states)), ncol = 1, nrow = length(states))
  
  #Rename the rows of the matrix to correspond to a state.
  rownames(initialDistribution) <- states
  
  initialDistribution[givenState,1] <- 1
  
  return(initialDistribution)
}

transition_matrix_one <- function(states, pointsScoredFrequency) {
  
  #Calculate the relative frequency of each observation in the points scored matrix.
  pointsScoredRelativeFrequency <- pointsScoredFrequency / sum(pointsScoredFrequency)
  
  x <- length(states)
  transitionMatrixOne <- matrix(rep(0, x^2), nrow = x, ncol = x)
  rownames(transitionMatrixOne) <- states
  colnames(transitionMatrixOne) <- states
  
  for(previousState in rownames(transitionMatrixOne)) {
    
    previousStateSplit <- strsplit(previousState, '-')[[1]]
    tryCatch({
      for(previousWinningTeamPointsScored in colnames(pointsScoredRelativeFrequency)) {
        updatedWinningTeamScore <- as.numeric(previousStateSplit[1]) + as.numeric(previousWinningTeamPointsScored)
        for(previousLosingTeamPointsScored in rownames(pointsScoredRelativeFrequency)) {
          updatedLosingTeamScore <- as.numeric(previousStateSplit[2]) + as.numeric(previousLosingTeamPointsScored)
          newWinningTeamSCore <- max(updatedWinningTeamScore, updatedLosingTeamScore)
          newLosingTeamScore <- min(updatedWinningTeamScore, updatedLosingTeamScore)
          nextState <- paste(newWinningTeamSCore, newLosingTeamScore, sep = "-")
          transitionMatrixOne[previousState,nextState] <- transitionMatrixOne[previousState, nextState] + pointsScoredRelativeFrequency[previousLosingTeamPointsScored,previousWinningTeamPointsScored]
        }
      }},
      error=function(e){
        transitionMatrixOne[previousState, ] <- rep(0,x)
        transitionMatrixOne[previousState, previousState] <- transitionMatrixOne[previousState, previousState] + 1})
  }
  
  for(previousState in rownames(transitionMatrixOne)) {
    if(sum(transitionMatrixOne[previousState, ]) != 1) {
        transitionMatrixOne[previousState, ] <- rep(0,x)
        transitionMatrixOne[previousState, previousState] <- 1
    }
  }
  
  return(transitionMatrixOne)
}

transition_matrix_two <-function(states, pointsScoredFrequency) {
  
  #Calculate the relative frequency of each amount of points scored for the winning team.
  winningTeamPointsScoredRelativeFrequency <- colSums(pointsScoredFrequency) / sum(pointsScoredFrequency)

  #Calculate the relative frequency of each amount of points scored for the winning team.
  losingTeamPointsScoredRelativeFrequency <- rowSums(pointsScoredFrequency) / sum(pointsScoredFrequency)
  
  transitionMatrixTwo <- matrix(rep(0, x^2), nrow = x, ncol = x)
  rownames(transitionMatrixTwo) <- states
  colnames(transitionMatrixTwo) <- states

  for(previousState in rownames(transitionMatrixTwo)) {
    previousStateSplit <- strsplit(previousState, '-')[[1]]
    tryCatch({
      for(previousWinningTeamPointsScored in as.character(0:31)) {
        updatedWinningTeamSCore <- as.numeric(previousStateSplit[1]) + as.numeric(previousWinningTeamPointsScored)
        winningTeamPointsScoredProbability <- winningTeamPointsScoredRelativeFrequency[previousWinningTeamPointsScored]
        for(previousLosingTeamPointsScored in as.character(0:31)) {
          updatedLosingTeamScore <- as.numeric(previousStateSplit[2]) + as.numeric(previousLosingTeamPointsScored)
          newWinningTeamSCore <- max(updatedWinningTeamSCore, updatedLosingTeamScore)
          newLosingTeamScore <- min(updatedWinningTeamSCore, updatedLosingTeamScore)
          nextState <- paste(newWinningTeamSCore, newLosingTeamScore, sep = "-")
          losingTeamPointsScoredProbability <- losingTeamPointsScoredRelativeFrequency[previousLosingTeamPointsScored]
          transitionMatrixTwo[previousState, nextState] <- transitionMatrixTwo[previousState, nextState] + winningTeamPointsScoredProbability * losingTeamPointsScoredProbability
          #print(paste(previousState, nextState, transitionMatrixTwo[previousState, nextState], sep = ", "))
        }
      }},
      error=function(e){
        transitionMatrixTwo[previousState, ] <- rep(0,x)
        transitionMatrixTwo[previousState, previousState] <- transitionMatrixTwo[previousState, previousState] + 1})
  }
  
  for(previousState in rownames(transitionMatrixTwo)) {
    if(sum(transitionMatrixTwo[previousState, ]) != 1) {
        transitionMatrixTwo[previousState, ] <- rep(0,x)
        transitionMatrixTwo[previousState, previousState] <- 1
    }
  }

  
  return(transitionMatrixTwo)
}

state_probability_distribution <- function(originVector, transitionMatrix, quartersRemaining) {
  library(expm)
  return(t(transitionMatrix%^%quartersRemaining)%*%originVector)
  
}
```


### Data Scraping

#### Install nflscrapR

  The data for this analysis was collected using nflscrapR which is an R package that is used to "utilize and analyze data from the National Football League (NFL) API" (How). It is necessary to install it in order to scrape data pertaining to NFL box scores. The nflscrapR package can be found at https://github.com/maksimhorowitz/nflscrapR. The devtools package can install R packages hosted on Github.
  
```{r Installation of nflscrapR, message=FALSE}

#Load the devtools library to install packages found on github.
library(devtools)

#Install nflscrapR from the designated Github repository.
devtools::install_github(repo = "maksimhorowitz/nflscrapR")

```

#### Scrape Individual Games

  Ten years worth of regular and post season games between 2009 and 2018 are collected for analysis. During this period, 2560 regular season games and 120 postseason games were played in the NFL. Each observation represents a unique game. Each game has 10 variables that record: a unique game ID; the game's type which indicates whether the game is a regular season or postseason game; the home team; the away team; the week of the season that the game was played; the score of the home team at the end of the game; the score of the away team at the end of the game; a unique url associated with the game; and the status of the game indicating whether the game is finished or ongoing.

```{r Scrape  Individual Games, message=FALSE, cache=TRUE}

#Scrape all regular and post season game ids from 2009 to 2018.
#scrapedGameIDs <- multi_scrape_game_ids(2009:2018, c("reg", "post")) #This is the original line.
load("scrapedGameIDs.Rda")

#Save scraped game ids to file.
save(scrapedGameIDs, file = "scrapedGameIDs.Rda")

#dplyr is used to select or deselect certain variables for in a data set. 
library(dplyr)

#Display the first six observations.
head(select(scrapedGameIDs, -c("game_url", "state_of_game")))
```

#### Scrape Game Play-by-Play

  All previously scraped game IDs collected from 2009 to 2018 are used to get play-by-play data. Each observation represents a unique play. The only variables collected from the play-by-play were; the unique game id; the home team, the away team; the quarter the play happened; the home score; and the away score. All other variables were discarded. For this analysis, it is necessary to record the scores at the end of each of the 4 quarters because that is considered a state. All observations that are not indicated as resulting in the quarter ending are also discarded. This action is executed by conditioning the data on a variable that indicates whether the quarter ends immediately after the play occurs.

```{r Scape Game Play-by-Play, message=FALSE, cache=TRUE}

#Load the scraped game ids data frame from file.
load("scrapedGameIDs.Rda")

#Scrape play-by-play data of all selected games.
#scrapedGamePlayByPlay <- multi_scrape_game_play_by_play(scrapedGameIDs)
load("scrapedGamePlayByPlay.Rda")

#Save scraped game play-by-play data to file.
save(scrapedGamePlayByPlay, file = "scrapedGamePlayByPlay.Rda")

#Display the first six observations.
head(scrapedGamePlayByPlay)
```

#### Combine Data Sets

  The two data sets are merged together so that each observation in the merged data set will represent one game. The structure of the merged data set is the same as the scraped individual game data set. The score at the end of each quarter, which is information found in the play-by-play data set, is added to each observation in the merged data set.

```{r Combine Data Sets}

#Load both scraped datasets.
load("scrapedGameIDs.Rda")
load("scrapedGamePlayByPlay.Rda")

#Merge the scaped game Id dataset and the scraped game play-by-play data set.
gameData <- game_data(scrapedGameIDs, scrapedGamePlayByPlay)

#Save merged game data to file.
save(gameData, file = "gameData.Rda")
```

  The first six observations demonstrate the limitations of how the data was originally recorded. Some plays that were the last play of the quarter were not properly recorded as such. When this error in the NFL's records occurs, an NA will be recorded in the data set. It is not ideal to have missing data. However it is possible to proceed to the construction of the points scored distributions. If the score is missing at the end of one quarter for any game, there is still 2 or 3 quarters where the amount of points scored is known. That information can still be used to construct the points scored distributions.

```{r Comment Head of Game Data}

#Load the merged data set.
load("gameData.Rda")

#Display the first six observations.
head(gameData)
```

### The Markov Chain Representation

#### Possible States

  As described before, each state will include two scores. The first score is the winning team's total points and the second score is the losing team's total points. The winning and losing teams may be tied but (for this analysis) it is considered trivial which actual team is considered the winning and losing team. The minimum points scored by a team in one quarter is 0 points for the data set. On the other hand, the maximum points scored in one quarter by a team is 31 for the data set. Although unlikely, we consider the probability of a team scoring 31 points every quarter to have a non-zero probability. In an NFL game there are four steps representing a quarter that is played. By definition the final score of the winning team is always greater than or equal the final score of the losing team. The possible states are:
  {"w-l"|w and l are elements of the set of integers between 0 and 124, w >= l}

```{r Possible States}

#Create a vector of states with the first element being the score "0-0".
states <- c("0-0")

#Loop through each of the possible states,"w-l".
#Add the result to the states vector.
for(w in 1:124) {
  for(l in 0:w) {
    states[[length(states)+1]] <- paste(w,l, sep ="-")
  }
}

#Save the states vector to file.
save(states, file="states.Rda")
```

#### Missing States

![Scorigami Matrix Found at www.nflscorigami.com](https://raw.githubusercontent.com/austinredmond/ScorigamiMC/master/nflscorigami.JPG?token=ACHPHCV3EIWTKC4RXC7GC4255BPLC)

  The diagram above illustrates most of the possible states that are considered in this analysis. Black squares are not considered possible states. Green squares indicate that the final score has occurred at least once. The white squares represent a final score that has never occurred before. A scorigami occurs whenever a unique final score occurs for the first time. Pro football reference provides a data set including all the missing final scores that have never occurred before.
  
```{r Missing States}

#Load the missing score data from csv.
missingScoresData <- read.csv(file="missingScores.csv", header = TRUE, sep = ",")

#The all missing states between "2-2" and "70-70".
missingStates <- as.character(missingScoresData$Score)

#Add each state between "71-0" and "124-124"
for(w in 71:124) {
  for(l in 0:w) {
    missingStates[[length(missingStates)+1]] <- paste(w,l, sep="-")
  }
}

#Remove the states "72-41" and "73-0" because they have occurred before.
missingStates <- setdiff(missingStates, c("72-41", "73-0"))

save(missingStates, file="missingStates.Rda")
```

#### Initial Distribution

  The initial distribution defines the probability of each state at the start. In the context of an NFL game, only one score can exist at a time. As every game starts with a score of 0 to 0, a standard initial distribution will have 100% probability of being state "0-0". It is possible to start the projection at other points in time such as the start of the second, third, and fourth quarters. If this is the case, the number of transitions will need to reflect the different point in time.
  
```{r Initial Distribution}

load("states.Rda")

standardInitialDistribution <- initial_distribution(states, "0-0")

save(standardInitialDistribution, file="standardInitialDistribution.Rda")
```

#### Points Scored Distributions

  The first step in constructing the transition matrices is to determine the distribution of points scored by a team in a quarter. The winning team in a given quarter is defined as the team that is winning the game at the start of the quarter. While the losing team in a given quarter is defined as the team that is losing the game at the start of the quarter. If the teams are tied at the start of the quarter, then the team that scored more points in that quarter is considered the winning team. The winning team and losing team can change from quarter-to-quarter. 
  The graph below plots the points scored by the winning team and the losing team in one quarter for every quarter recorded in the data set. A single observation includes the points scored from both teams. The x-axis shows the quantity of points scored by the winning team in one quarter. The winning team has scored anywhere from 0 to 31 points. The x-axis shows the quantity of points scored by the losing team in one quarter. The losing team has scored anywhere from 0 to 28 points. 
  The color of each cell in the grid represents the amount of observations where the winning team and the losing team specifically scored that many points in a quarter. This means that we are treating the scores of the winning team and losing team as dependent. There are 10 colors representing ten bins. The first bin has a black color and each bin thereafter is a lighter color. The tenth bin therefore is yellow. Any cell that is white has no observations. The size of the bins were determined so that they contain roughly the same number of observations. They are as follows: bin 1 (1 observation),  bin 2 (2 observations),  bin 3 (3 observations),  bin 4 (4-5 observations),  bin 5 (6-9 observations),  bin 6 (10-14 observations),  bin 7 (14-50 observations),  bin 8 (51-100 observations),  bin 9 (101-150 observations), and  bin 10 (151 observations or greater).
```{r Points Scored Frequency Matrix, error= FALSE, message = FALSE}
#Load the game data.
load("gameData.Rda")

#Get the frequency of how many points are scored by the the two teams within the game data. This functiomn will return a matrix.
pointsScoredFrequency <- points_scored_frequency(gameData)

#Save the points scored frequency matrix to file.
save(pointsScoredFrequency, file="pointsScoredFrequency.Rda")

#Load the plot.matrix and viridis libraries to create a graph of the points scored frequency matrix.
library(plot.matrix)
library(viridis)

#Plot the points scored frequency matrix,
x <- pointsScoredFrequency
x[x==0] <- NA
plot(x, breaks=c(0,1,2,3,5,9,14,50,100,150,1000),col = magma, main="Points Scored Frequency Matrix", xlab = "Winning Team Points Scored in One Quarter", ylab = "Losing Team Points Scored in One Quarter")
```
  
  When observing the graph, it is clear that many combinations of scores have not occurred in period of 2009 to 2018. Given the yellow cells, it is evident that the most common combinations of scores are those where both teams have a score that is a linear transformation of [3x+7y] where x and y are 0, 1, or 2. This result is intuitive given that: first the 3-point field goal and the 7-point touchdown with successful point-after attempt are the most common ways to score and second it is difficult to score on 3 or more drives in a quarter as each quarter is time constrained to 15 minutes of game time. Scores that are only possible using at least one 2-point safety and/or 8-point touchdown are very unlikely to occur. A few examples of unlikely amounts of points scored in a quarter are 2, 4, 5, 8, 11, and 15 to name a few. Columns or rows featuring a rare score like those mentioned are likely to be mostly white, black, or darker shades of purple.
  The amount of points scored by the winning and losing teams may or may not be independent. Only one team can have possession of the ball at any given point in time. It would be expected that a higher score by one team means that the other team has less position time. However, it is difficult to claim that the chance of scoring a rare score in a quarter is more or less likely based on the other team also scoring a rare score. The graph above shows many combinations of scores as impossible (the cell is white) when they are merely improbable. The sample of only includes 6691 different quarters. Given a larger sample size it is possible for more combinations to occur. Given this it is appropriate to build two different transition matrices based on two different assumptions.
  Assumption #1: The points scored by each team is dependent. We should consider the points scored in the same quarter of the same game as dependent on each other.
  Assumption #2: The points scored by each team is independent. We should consider distribution of points scored by the winning team and the losing team as two different distributions that exist separately.
```{r Get Points Scored Distributions, error=FALSE}

#Get the individual observations from the points scored frequency mattrix.
pointsScoredObservations <- points_scored_observations(pointsScoredFrequency)

#Save the individual points scored matrix to file.
save(pointsScoredObservations, file="pointsScoredObservations.Rda")

#Load the ggplot2 library to creat a histogram with two distributions.
library(ggplot2)

#Create a histogram that graphs the winning team points scored and the losing team points scored separately.
ggplot() + 
  geom_histogram(aes(x = pointsScoredObservations$losing_team_points_scored, fill = "r"), alpha = 0.3, bins = 31) +
  geom_histogram(aes(x = pointsScoredObservations$winning_team_points_scored, fill = "b"), alpha = 0.3, bins = 31) +
  scale_colour_manual(name ="Histograms of Points Scored", values = c("r" = "red", "b" = "blue"), labels=c("b" = "Winning Team", "r" = "Losing Team")) +
  scale_fill_manual(name ="Legend", values = c("r" = "red", "b" = "blue"), labels=c("b" = "Winning Team", "r" = "Losing Team"))+
  labs(title = "Histograms of Points Scored", x = "Points Scored in One Quarter", y = "Frequency")






pointsScoredRelativeFrequency <- pointsScoredFrequency / sum(pointsScoredFrequency)
save(pointsScoredRelativeFrequency, file="pointsScoredRelativeFrequency.Rda")

winningTeamPointsScoredRelativeFrequency <- colSums(pointsScoredFrequency) / sum(pointsScoredFrequency)
save(winningTeamPointsScoredRelativeFrequency, file="winningTeamPointsScoredRelativeFrequency.Rda")

losingTeamPointsScoredRelativeFrequency <- rowSums(pointsScoredFrequency) / sum(pointsScoredFrequency)
save(losingTeamPointsScoredRelativeFrequency, file="losingTeamPointsScoredRelativeFrequency.Rda")



```
  
  The histogram above represents the distributions of points scored by each of the winning and losing teams. The winning teams are designated with the color blue and the losing teams are designated with the color red. It can be observed that the distributions are not normal. The same common scores (0,3,7,10...) and rare scores (2,4,5, 8...) noted previously are also displayed convincingly in this histogram. In terms of differences between the histograms. It can be observed that the losing teams score 0 points in a given quarter way more more often than the winning teams. If a team is losing at the start of a quarter, it is not surprising that they are more likely to score 0 points in that quarter because they are probably a worse offensive team. For the most part, the winning teams have more observations where the points scored is above 3 or above. However, there are three counter-examples that are interesting. When the points scored is 8, 11, or 15, there are more observations for the losing teams. If a team is losing, then they will play riskier in order to catch up to the team that is winning. Riskier play will result in teams that are more willing to go for a 2-point conversion attempt. If they are successful, then their points scored for that quarter will be a linear transformation of [3x+7y+8z] where 8 is equal to 1. The scores of 8, 11, and 15 are all likely in the described scenario.

#### Transiton Matrix

```{r Transition Matrix}

#Load the states vector and the points scored frequency matrix.
load("states.Rda")
load("pointsScoredFrequency.Rda")

#Construct the first matrix based on assumption #1.
#transitionMatrixOne <- transition_matrix_one(states, pointsScoredFrequency) #This is the original line.
load("transitionMatrixOne.Rda")

#Save the first transition matrix to file.
save(transitionMatrixOne, file="transitionMatrixOne.Rda")

#Construct the second matrix based on assumption #2
#transitionMatrixTwo <- transition_matrix_two(states, pointsScoredFrequency) #This is the original line.
load("transitionMatrixTwo.Rda")

#Save the second transition matrix to file.
save(transitionMatrixTwo, file="transitionMatrixTwo.Rda")

```

#### Probability of Each State After 4 Steps

```{r}

#Load the standard origin Matrix which designates that every game begins with a score of "0-0" with 100% probability.
load("standardOriginVector.Rda")

load("transitionMatrixOne.Rda")
stateProbabilityDistributionOne <- state_probability_distribution(standardOriginVector, transitionMatrixOne, 4)
save(stateProbabilityDistributionOne, file = "stateProbabilityDistributionOne.Rda")

load("transitionMatrixTwo.Rda")
stateProbabilityDistributionTwo <- state_probability_distribution(standardOriginVector, transitionMatrixTwo, 4)
save(stateProbabilityDistributionTwo, file = "stateProbabilityDistributionTwo.Rda")

x <- stateProbabilityDistributionOne[is.element(rownames(stateProbabilityDistributionOne), scorigamiStates)]
x <- matrix(x, ncol = 1, nrow = length(x))
rownames(x) <- scorigamiStates
sum(x)

y <- stateProbabilityDistributionTwo[is.element(rownames(stateProbabilityDistributionTwo), scorigamiStates)]
y <- matrix(y, ncol = 1, nrow = length(y))
rownames(y) <- scorigamiStates
sum(y)

scenarioOneOriginVector <- standardOriginVector
scenarioOneOriginVector["0-0",] <- 0
scenarioOneOriginVector["2-2",] <- 1
stateProbabilityDistributionScenarioOne <- state_probability_distribution(scenarioOneOriginVector, transitionMatrixOne, 3)

z <- stateProbabilityDistributionScenarioOne[is.element(rownames(stateProbabilityDistributionScenarioOne), scorigamiStates)]
z <- matrix(z, ncol = 1, nrow = length(z))
rownames(z) <- scorigamiStates
sum(z)

scenarioOneOriginVector <- standardOriginVector
scenarioOneOriginVector["0-0",] <- 0
scenarioOneOriginVector["2-2",] <- 1
stateProbabilityDistributionScenarioOne <- state_probability_distribution(scenarioOneOriginVector, transitionMatrixOne, 3)

z <- stateProbabilityDistributionScenarioOne[is.element(rownames(stateProbabilityDistributionScenarioOne), scorigamiStates)]
z <- matrix(z, ncol = 1, nrow = length(z))
rownames(z) <- scorigamiStates
sum(z)

scenarioTwoOriginVector <- standardOriginVector
scenarioTwoOriginVector["0-0",] <- 0
scenarioTwoOriginVector["25-2",] <- 1
stateProbabilityDistributionScenarioTwo <- state_probability_distribution(scenarioTwoOriginVector, transitionMatrixOne, 1)

a <- stateProbabilityDistributionScenarioTwo[is.element(rownames(stateProbabilityDistributionScenarioTwo), scorigamiStates)]
a <- matrix(a, ncol = 1, nrow = length(z))
rownames(a) <- scorigamiStates
sum(a)
```




# Works Cited

Bois, John. "Every NFL Score Ever | Chart Party". *Youtube*, SB Nation, December 7, 2016, https://www.youtube.com/watch?v=9l5C8cGMueY.

Colon, David. "Jon Bois, editor at SB Nation, on making a career of weird sportswriting". Brokelyn, August 3, 2015. https://brokelyn.com/howd-get-cool-job-jon-bois-sb-nation-making-career-weird-sportswriting/.

Nogle, Kevin. "Football 1010: The one-point safety". The Phinsider, March 3, 2018. https://www.thephinsider.com/2018/3/3/17063556/football-101-the-one-point-safety.

NFL Scorigami. "NFL Scorigami". Dec 2, 2019. https://nflscorigami.com/ Accessed 2 December 2019.

Horowitz, Marksim. "Introducing the nflscrapR Package". Github, https://github.com/maksimhorowitz/nflscrapR. Accessesd 15 November 2019.

Pro Football Reference. "Missing Games in Pro Football History". Dec 2, 2019. https://www.pro-football-reference.com/boxscores/missing-scores.htm Accessed 2 December 2019.

https://seahawkswire.usatoday.com/2018/12/03/seahawks-continue-bizarre-scorigami-streak-under-pete-carroll/
